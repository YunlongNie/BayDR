{
    "contents" : "#' Compute the Sold.\n#'\n#' This function computes the old saturated estimators\n#'\n#' @param Y response varaible\n#' @param X exposure\n#' @param C confounder matrix\n#' @seealso \\code{\\link{Allest_C.R}}\n#' @param prior0,prior1 prior parameter of the saturated old estimate\n#' @param kappa the prior weight when calculating the bayesian esimate\n#' @param beta the prior of the paramatric estimate\n#' @param Mc.error(0.001), controls the Mc.error when estimating the parametric estimate\n#' @return a list of  saturated old estimate and its likelihood\n#' @export\n#' @importFrom plyr dlply\n#' @importFrom boot inv.logit\n#' @importFrom LaplacesDemon as.inverse\n#' @importFrom mnormt dmnorm\n#' @examples\n#' \\dontrun{\n#' AllEstD_C <- function(Y,X,C,k_q=1,prior0=c(1,1),prior1=c(1,1))\n#' }\nsat.est.old <- function(Y,X,C,k_q,prior0,prior1,Dat) {\n  if (missing(Y)|missing(X)|missing(C)) {Y=Dat$Y;X=Dat$X;C=Dat[,paste0(\"C\",1:(ncol(Dat)-2))]}\n  if (missing(Dat)&(missing(Y)|missing(X)|missing(C))) stop(\"Data entry wrong Y or X or C or Dat is missing\") \n  if (missing(k_q)) k_q=1\n  if (missing(prior0)) \n  {\n    a0=b0=1\n  }\n  else {a0=prior0[1]*prior0[2];b0=prior0[2]-a0}\n  \n  if (missing(prior1)) \n  {\n    a1=b1=1\n  }\n  else {a1=prior1[1]*prior1[2];b1=prior1[2]-a1}\n  \n  Dat <- as.data.frame(cbind(C,X,Y)) # combine the C confounder, X exposure and Y response into a dataset\n  no.confounder = ncol(C) # number of confounders\n  level.con <- 2^no.confounder # levels of confounder's combination\n  no.ob <- nrow(Dat) # number of observations\n  names(Dat) <- c(paste(\"C\",1:no.confounder,sep=\"\"),\"X\",\"Y\")\n  Dat$X <- factor(Dat$X)\n  Dat$Y <- factor(Dat$Y)\n  temp.list <- dlply(Dat,paste(\"C\",1:no.confounder,sep=\"\"),\n                     function(x) {\n                       temp.table <- table(x[,(no.confounder+1):(no.confounder+2)])\n                       as.numeric(temp.table)\n                     }\n  )\n  UqC <- attr(temp.list,\"split_labels\")\n  N..Number <- as.data.frame(do.call(rbind,lapply(temp.list,function(x) c(x[4],x[4]+x[2],x[3],x[3]+x[1],sum(x)))))\n  colnames(N..Number) <- c('C11','C1.','C01','C0.','Number') # matrix for n_cxx \n  rownames(N..Number) <- 1:nrow(N..Number)\n  N..Number0 <- N..Number[,3:4];N..Number1 <- N..Number[,1:2] # for C=0 & for C=1\n  n.full <- nrow(UqC)                 ###  # non-empty cells               \n  n.mpty <- level.con-n.full               ###  # empty cells \n  \n\n  DeltaS = ApplyCSold(Number=as.matrix(N..Number),kq=k_q,levelCon=level.con,\n                 noObs=no.ob,a1=a1,a0=a0,b0=b0,b1=b1)\n  estimate.s.old<- sum(DeltaS) + n.mpty*k_q/(level.con*k_q + no.ob)*(a1/(a1+b1)-a0/(a0+b0)) \n\n   \n  likelihood.old = sum(ApplyCSoldhood(Number=as.matrix(N..Number),a1=a1,b1=b1,a0=a0,b0=b0))\n  \n  return(\n    list(est.old=estimate.s.old, # without smoothing for the prior\n         likelihood.old=likelihood.old \n         )\n  )  \n}\n",
    "created" : 1374084522653.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2865506265",
    "id" : "D2012272",
    "lastKnownWriteTime" : 1373606988,
    "path" : "~/Dropbox/UBC/CinR/FileOnSever/Mypackages/Import/R/sat.est.old.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}