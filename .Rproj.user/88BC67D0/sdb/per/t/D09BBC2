{
    "contents" : "#' Compute the P.\n#'\n#' This function computes paramatrix estimator.\n#'\n#' @param Y response varaible\n#' @param X exposure\n#' @param C confounder matrix\n#' @param beta prior matrix for the paramatric model\n#' @param Mc.error default 0.001\n#' @importFrom plyr dlply\n#' @importFrom boot inv.logit\n#' @importFrom LaplacesDemon as.inverse as.symmetric.matrix\n#' @importFrom mnormt dmnorm\n#' @importFrom speedglm speedglm\n#' @export\n#' @examples\n#' \\dontrun{\n#' para.est <- function(Y,X,C,beta,k_q=1,Mc.error=0.001)\n#' }\npara.est <- function(Y,X,C,beta,k_q=1,Mc.error=0.001,Dat) {\n  \n \n  if (missing(Y)|missing(X)|missing(C)) {\n    Y=Dat$Y;X=Dat$X;C=Dat[,paste0(\"C\",1:(ncol(Dat)-2))]\n  }\n  if (missing(Dat)&(missing(Y)|missing(X)|missing(C))) stop(\"Data entry wrong Y or X or C or Dat is missing\") \n  if (missing(beta)) {\n    beta=30^2*diag(rep(1,ncol(C)+2))\n  }\n  if (missing(k_q)) {\n    k_q=1\n  }\n  if (missing(Mc.error)) {\n    Mc.error=0.001\n  }\n  Dat <- cbind(C,X,Y) # combine the C confounder, X exposure and Y response into a dataset\n  no.confounder = ncol(C) # number of confounders\n  level.con <- 2^no.confounder # levels of confounder's combination\n  no.ob <- nrow(Dat) # number of observations\n  \n  Dat <- as.data.frame(Dat)\n  names(Dat) <- c(paste(\"C\",1:no.confounder,sep=\"\"),\"X\",\"Y\")\n  Dat$X <- factor(Dat$X)\n  Dat$Y <- factor(Dat$Y)\n  temp.list <- dlply(Dat,paste(\"C\",1:no.confounder,sep=\"\"),\n                     function(x) {\n                       temp.table <- table(x[,(no.confounder+1):(no.confounder+2)])\n                       as.numeric(temp.table)\n                     }\n  )\n  UqC <- attr(temp.list,\"split_labels\")\n  N..Number <- as.data.frame(do.call(rbind,lapply(temp.list,function(x) c(x[4],x[4]+x[2],x[3],x[3]+x[1],sum(x)))))\n  colnames(N..Number) <- c('C11','C1.','C01','C0.','Number') # matrix for n_cxx \n  rownames(N..Number) <- 1:nrow(N..Number)\n  \n  \n  n.full <- nrow(UqC)                 ###  # non-empty cells               \n  n.mpty <- level.con-n.full               ###  # empty cells \n  \n  Dat$X <-X # otherwise Hatm1C1 might have some error. \n  Dat$Y <-Y\n  forglm=as.formula(\n    paste(\"Y ~ \",paste(\"C\",1:(ncol(Dat)-2),collapse=\"+\",sep=\"\"),\"+X\")\n  )\n  outModel <- speedglm(forglm,data=Dat,family=binomial())\n  Hatm1C1 <- inv.logit(as.matrix(cbind(1,UqC,1))%*%as.matrix(coef(outModel)))\n  Hatm0C0 <- inv.logit(as.matrix(cbind(1,UqC,0))%*%as.matrix(coef(outModel)))\n  \n  PrC <- apply(N..Number,1,function(x) {\n    \n    (k_q+x[5])/(level.con*k_q+no.ob)\n    \n  })\n  if (n.mpty==0) { estimate.p <- sum(PrC*(Hatm1C1-Hatm0C0)) } else { \n    if ( no.confounder <=20) {\n      CSample.temp = do.call(expand.grid, rep(list(c(0,1)),no.confounder))\n      total = apply(CSample.temp,1,function(x) sum(2^(0:(length(x)-1))*x))\n      UqC.total  = apply(UqC,1,function(x) sum(2^(0:(length(x)-1))*x))\n      CSample = CSample.temp[!total%in%UqC.total,]\n    } else {\n    CSample = sample.empty(N=(0.5/Mc.error)^2,UqC=as.matrix(UqC))\n    }\n    Hatm1C1full <- inv.logit(as.matrix(cbind(1,CSample,1))%*%as.matrix(coef(outModel)))\n    Hatm0C0full <- inv.logit(as.matrix(cbind(1,CSample,0))%*%as.matrix(coef(outModel)))\n    \n    estimate.p <- mean(Hatm1C1full-Hatm0C0full)*k_q*n.mpty/(level.con*k_q+no.ob) + sum(PrC*(Hatm1C1-Hatm0C0))\n  } \n    \n  \n  \n  theta <- matrix(nrow=no.confounder+2, as.numeric(coef(outModel))) # MLE \\beta\n  H <- as.inverse(as.symmetric.matrix(vcov(outModel)))\n  Sigma_star <- as.inverse(as.inverse(beta)+H)\n  beta_star <- Sigma_star%*%H%*%theta \n  phi <- dmnorm(x=as.numeric(beta_star),mean=rep(0,no.confounder+2),varcov= beta)/\n    dmnorm(x=as.numeric(beta_star),mean=as.numeric(beta_star),varcov = Sigma_star)\n  Dat$X <- as.numeric(Dat$X)\n  temp= as.matrix(cbind(inter=1,(Dat[,-no.confounder-2])))\n  fy <- inv.logit(temp%*%as.matrix(beta_star))\n  likelihood.p <- sum(log(fy^Y*(1-fy)^(1-Y))) + log(phi) # likelihood of parametric estimate \n  output <- list(P=estimate.p,likelihood=likelihood.p)\n  \n  \n  return(\n    output \n  )  \n}\n\n",
    "created" : 1374083283341.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3144496348",
    "id" : "D09BBC2",
    "lastKnownWriteTime" : 1373857889,
    "path" : "~/Dropbox/UBC/CinR/FileOnSever/Mypackages/Import/R/para.est.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}